from collections.abc import Iterable
from importlib import import_module
import claripy

# List of operation methods that are not parsed
OP_IGNORE_LIST=["fpToFP", "fpToFPUnsigned", "And", "Or"]

def get_closure_var(fn, var):
    k = fn.__code__.co_freevars
    v = [c.cell_contents for c in fn.__closure__]
    return dict(zip(k,v))[var]

def getSubCls(cls, nb_tab=0):
    direct_sub_nodes = []
    indirect_sub_nodes = []
    ops = []

    if len(cls.__subclasses__()) == 0:
        direct_sub_nodes.append((cls.__name__, [cls.__name__+"V", cls.__name__+"S"]))
        indirect_sub_nodes.append((cls.__name__+"V", []))
        indirect_sub_nodes.append((cls.__name__+"S", []))
    else:
        sub_nodes = []
        for sub_cls in cls.__subclasses__():
            tmp_nodes_dir, tmp_nodes_indir, tmp_ops = getSubCls(sub_cls, nb_tab+1)
            sub_nodes.extend(tmp_nodes_dir)
            indirect_sub_nodes.extend(tmp_nodes_dir)
            indirect_sub_nodes.extend(tmp_nodes_indir)
            ops.extend(tmp_ops)

        sub_cls = []
        for c, dep in sub_nodes:
            sub_cls.append(c)
        direct_sub_nodes.append((cls.__name__, sub_cls))

    cls_module = import_module(cls.__module__)
    potential_op_method_names = dir(cls)
    module_names = [names for names in dir(cls_module) if names not in potential_op_method_names]
    potential_op_method_names.extend(module_names)
    potential_op_methods = [getattr(cls, m) for m in dir(cls)]
    potential_op_methods.extend([getattr(cls_module, m) for m in module_names])
    op_meth = []
    for m, meth in zip(potential_op_method_names, potential_op_methods):
        try:
            if  meth.__name__ == "_op" and m not in OP_IGNORE_LIST:
                _type_fixer_meth = get_closure_var(meth, '_type_fixer')
                arg_types = get_closure_var(_type_fixer_meth, 'arg_types')
                return_type = get_closure_var(meth, 'return_type')
                if isinstance(arg_types, Iterable):
                    op_meth.append((cls.__name__+"_"+m, arg_types, return_type))
                else:
                    # For concat op, the type arg should be doubled, not sure why
                    # See ast/strings.py and operations.py on claripy source tree
                    op_meth.append((cls.__name__+"_"+m, [arg_types, arg_types], return_type))
        except AttributeError:
            pass

    for m, arg_types, return_type in op_meth:
        ops.append((str(m), [t.__name__ for t in arg_types], return_type.__name__))

    return direct_sub_nodes, indirect_sub_nodes, ops

ast_nodes, ast_nodes_indir, ast_ops = getSubCls(claripy.ast.base.Base)
ast_nodes.extend(ast_nodes_indir)

proto_file = "// Generated by %s\n\nsyntax = \"proto3\";\n\noption java_package = \"lu.uni.trux.jucify.callgraph\";\n\n" % __file__

proto_file += "message IfBlock{\n  Bool condition = 1;\n  Base then_block = 2;\n  Base else_block = 3;\n}"

for n, dep in ast_nodes:
    proto_file += "\n\nmessage %s {\n" % n
    i = 1
    
    if len(dep):

        # IfBlock can be any type
        # because its type is the one of the "then" or the "else"
        # both should be the same
        dep.append("IfBlock")
        
        proto_file += "  oneof sub_msg {\n"
        
        if n == "FP":
            proto_file += "    BV fromBv = %i;\n" % i
            i += 1

        for d in dep:
            proto_file += "    %s node_%s = %i;\n" % (d, d, i)
            i += 1

        first = True
        for op_n, _, ret_type in ast_ops:
            if ret_type == n :
                if first:
                    proto_file += "\n"
                    first = False
                proto_file += "    %s op_%s = %i;\n" % (op_n, op_n, i)
                i += 1

        proto_file += "  }\n"
    else:
        if n.endswith('V'):
            if n.startswith("String"):
                proto_file += "  string value = 1;\n"
            elif n.startswith("BV"):
                proto_file += "  uint64 value = 1;\n"
            elif n.startswith("Int"):
                proto_file += "  uint64 value = 1;\n"
            elif n.startswith("FP"):
                proto_file += "  double value = 1;\n"
            elif n.startswith("Bool"):
                proto_file += "  bool value = 1;\n"
        elif n.endswith('S'):
            proto_file += "  string symbol = 1;\n"
    proto_file += "}"

for n in ast_ops:
    proto_file += "\n\nmessage "
    if isinstance(n, tuple):
        proto_file += n[0] + " {\n"
        i = 1
        for arg in n[1]:
            if arg == "int":
                proto_file += "  uint64 arg%i = %i;\n" % (i, i)
            elif arg == "RM":
                proto_file += "  string arg%i = %i;\n" % (i, i)
            else:
                proto_file += "  %s arg%i = %i;\n" % (arg, i, i)
            i += 1
        proto_file += "  %s return = %i;\n" % (n[2], i)
    proto_file += "}"

print(proto_file)
